Step 1 [Portfolio.cs]: Create the Portfolio Model (Join Table)
    Purpose:
        - Defines a many-to-many relationship between AppUser and Stock using a join table.

    Key Details:
        - [Table] Attribute: Overrides default table naming (EF Core would name it Portfolio without this).
        - Composite Key: The combination of AppUserId + StockId uniquely identifies each row (configured later in DbContext).
        - Navigation Props: Enable EF Core to automatically load related AppUser/Stock data when querying Portfolios.

Step 2 [AppUser.cs]: Extend AppUser (IdentityUser)
    Purpose:
        - Adds a user-centric navigation property to access all stocks in a user's portfolio.
        - Answers the question: "What stocks does this user own?"

    Key Details:
        - List<Portfolio>: Represents all join table entries (Portfolios) linked to this user.
        - Unidirectional (at this stage): This property alone only lets you navigate from AppUser → Portfolio. The bidirectional aspect is only complete when Stock also references Portfolio.
        - Initialized as empty list: Avoids null reference exceptions when accessing user.Portfolios.

Step 3 [Stocks.cs]: Extend Stock Model
    Purpose:
        - Adds a stock-centric navigation property to track all users who own this stock.
        - Answers the question: "Who owns this stock?"

    Key Details:
        - List<Portfolio>: Represents all join table entries (Portfolios) linked to this stock.
        - Completes the Bidirectional Relationship:
            - Now you can navigate both ways:
                - AppUser → Portfolio → Stock ("What stocks does this user own?")
                - Stock → Portfolio → AppUser ("Who owns this stock?")
        - Initialized as empty list: Ensures stock.Portfolios is never null.

Step 4 [ApplicationDBContext.cs]: Configure Entity Framework Core (DbContext)
    Purpose:
    - Defines how EF Core maps the Portfolio model to the database.

    Key Details:
        Composite Primary Key:
            Uses both AppUserId and StockId as the key (no separate Id column needed).

        Relationship Configuration:
            - HasOne/WithMany: 
                - Defines a one-to-many relationship between AppUser/Stock and Portfolio.
            - Foreign Keys: 
                -Explicitly maps AppUserId and StockId as foreign keys.
            - Cascade Delete (Optional):
                - Automatically deletes Portfolio entries if the linked AppUser or Stock is deleted.

Step 5: Table Attributes for Models
    Purpose:
        - Ensure explicit table naming while avoiding conflicts with Identity's default tables.

    Key Notes:
        - Skip [Table] for AppUser: ASP.NET Core Identity already handles the table name (AspNetUsers).
        - Always use [Table] for custom models: Prevents EF Core from using default naming (e.g., Stock → Stocks).

    - Perfectly fine if you're working by yourself.
    - Not recommended if you have other collaborators.

Step 6: Reset Migrations and Database
    Purpose:
        - Clean slate for schema changes (e.g., after adding relationships).

    Warning:
        -- ✅ Safe for solo development.
        - ❌ Avoid in team projects (collaborators will need the latest DB schema).

    Steps:
        1.  Delete the Migrations Folder
            - Locate the Migrations folder in your project.
            - Delete it entirely (this removes all migration history).

        2. Delete the Database:
            - Option 1 (SSMS):
                - Open SQL Server Management Studio.
                - Right-click dotnet-8-pro → "Delete" (or "Drop").
            - Option 2 (Command Line):
                > dotnet ef database drop --force  # Forcefully deletes the DB

Step 7: Recreate Migrations and Database

    Purpose:
        - Generate fresh migrations reflecting your updated models (e.g., Portfolio relationships).
    
    Critical Note:
        - 🔴 Ensure your API server is not running (e.g., stop Swagger/Postman requests and shut down the dotnet run process).

    Commands:
        1. Create a new migration:
            > dotnet ef migrations add PortfolioManyToMany  # Names the migration
        2. Update the database:
            > dotnet ef database update
    
    Verification:
        - Check SSMS or run SELECT * FROM Portfolios to confirm the join table exists.

    Why This Works:
        - Clean migrations: Deleting old migrations avoids conflicts with schema changes (e.g., adding relationships).
        - Explicit table names: Prevents EF Core from assuming default names (critical for join tables).
        - Safe reset: Ensures the database matches your current model state.

N O T E :

    [CASE 1]
    - When working with collaborators, do not delete the migrations folder or database haphazardly. 
    - Instead, follow this collaborative workflow to manage schema changes safely:

    1. For Existing Migrations (Team Workflow)
        ✅ Do This:
            - Pull the latest migrations from your version control (Git):
                > git pull origin main
    
    2. Apply pending migrations to your local DB:
        > dotnet ef database update

    3. Create new migrations for your changes:
        > dotnet ef migrations add YourMigrationName
    
    4. Commit and push the new migration files:
        >   
            git add .
            git commit -m "Added Portfolio many-to-many relationship"
            git push origin your-branch

    [CASE 2]
    - If You Must Reset Migrations (Rare Cases)

    Scenario:
        -You need to recreate all migrations (e.g., after a major model overhaul).

    Safe Steps for Teams:
        1. Coordinate: Inform all collaborators to stop working on DB-related tasks.
        2. Backup the database (in case of data loss).
        3. Delete the Migrations folder locally.
        4. Create a new initial migration:
            > dotnet ef migrations add InitialCreate
        5. Generate a SQL script (for controlled deployment):
            > Generate a SQL script (for controlled deployment):

    [CASE 3]
    - Handling Database Conflicts

    - If a collaborator’s migration conflicts with yours:
        1. Revert your local changes:
            > dotnet ef migrations remove
        2. Pull their latest migration:
            > git pull origin main
        3. Recreate your migration on top of theirs:
            > dotnet ef migrations add YourFixedMigration
